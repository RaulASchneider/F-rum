<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Chat</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        #messages { border: 1px solid #000; height: 300px; overflow-y: auto; padding: 10px; margin-bottom: 20px;}
        form { display: flex; gap: 10px; }
        input { flex: 1; padding: 10px; }
    </style>
</head>
<body>

<h2>Chat</h2>

<div id="messages"></div>

<form id="sendForm">
    <input id="text" placeholder="Digite..." required />
    <button type="submit">Enviar</button>
</form>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script src="supabase.js"></script> <!-- assume 'db' é criado nesse arquivo -->

<script>
/* ---------------------- Estado e utilitários ---------------------- */
const messagesDiv = document.getElementById("messages");

// guarda ids já renderizados para evitar duplicação
const renderedMessageIds = new Set();

// cache simples de usernames para reduzir queries
const usernameCache = new Map();

/* ---------------------- CHECK USER ---------------------- */
async function checkUser() {
    const { data } = await db.auth.getUser();
    if (!data.user) {
        window.location.href = "login.html";
        return;
    }
    return data.user;
}

/* ---------------------- RENDER ---------------------- */
function renderMessage(msg) {
    // se já renderizamos essa mensagem (por id), ignora
    if (msg.id && renderedMessageIds.has(String(msg.id))) return;

    const el = document.createElement("p");

    const username = msg.profiles?.username ?? "(desconhecido)";
    const content = msg.content ?? "";

    el.textContent = username + ": " + content;
    messagesDiv.appendChild(el);

    // marcar como renderizado se houver id
    if (msg.id) renderedMessageIds.add(String(msg.id));

    messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

/* ---------------------- BUSCAR USERNAME (resiliente + cache) ---------------------- */
async function fetchUsernameAndRender(msg) {
    // se já veio com profiles, renderiza direto
    if (msg.profiles && msg.profiles.username) {
        renderMessage(msg);
        return;
    }

    // tenta cache
    if (msg.user_id && usernameCache.has(msg.user_id)) {
        msg.profiles = { username: usernameCache.get(msg.user_id) };
        renderMessage(msg);
        return;
    }

    // busca no banco - usar maybeSingle para evitar erro se não achar
    try {
        const { data, error } = await db
            .from("profiles")
            .select("username")
            .eq("id", msg.user_id)
            .maybeSingle();

        const username = (!error && data && data.username) ? data.username : "(desconhecido)";

        // cacheia se existir id real
        if (msg.user_id && username !== "(desconhecido)") usernameCache.set(msg.user_id, username);

        msg.profiles = { username };
    } catch (err) {
        // em caso de erro inesperado, garante valor padrão
        msg.profiles = { username: "(desconhecido)" };
        console.error("Erro ao buscar username:", err);
    }

    renderMessage(msg);
}

/* ---------------------- LOAD MESSAGES (com join profiles) ---------------------- */
async function loadMessages() {
    // tenta já trazer profiles(username) via relacionamento
    const { data, error } = await db
        .from("messages")
        .select("id, content, user_id, created_at, profiles(username)")
        .order("created_at");

    if (error) {
        console.error("Erro ao carregar mensagens:", error);
        return;
    }

    // renderizar todas as mensagens (cada uma pode já ter profiles)
    for (const msg of data) {
        // se veio username via join, cacheia
        if (msg.user_id && msg.profiles && msg.profiles.username) {
            usernameCache.set(msg.user_id, msg.profiles.username);
        }
        renderMessage(msg);
    }
}

/* ---------------------- SEND (injeta username do auth para feedback instantâneo) ---------------------- */
document.getElementById("sendForm").addEventListener("submit", async (e) => {
    e.preventDefault();

    const text = document.getElementById("text").value.trim();
    if (!text) return;

    const user = await checkUser();
    if (!user) return;

    // envia sem renderizar diretamente do retorno do insert com join (nem sempre join vem)
    const { data, error } = await db
        .from("messages")
        .insert({
            user_id: user.id,
            content: text
        })
        .select(); // traz id etc.

    if (error) {
        console.error("Erro:", error);
        alert(error.message || "Erro ao enviar mensagem");
        return;
    }

    // data[0] é a linha inserida. injetar username localmente para feedback imediato
    const inserted = data[0];

    // tenta extrair username do auth (user_metadata) — se não existir, tenta cache/perfil depois via realtime
    const usernameFromAuth = user.user_metadata?.username ?? user.user_metadata?.name ?? null;
    if (usernameFromAuth) {
        inserted.profiles = { username: usernameFromAuth };
        // cacheia
        usernameCache.set(user.id, usernameFromAuth);
        // renderiza imediatamente
        renderMessage(inserted);
    } else {
        // se não há username no auth, apenas renderiza com (desconhecido) temporariamente
        inserted.profiles = { username: "(desconhecido)" };
        renderMessage(inserted);
        // quando o realtime chegar, fetchUsernameAndRender tratará (e será ignorado se id já renderizado)
    }

    document.getElementById("text").value = "";
});

/* ---------------------- REALTIME ---------------------- */
db.channel("chat")
.on(
    "postgres_changes",
    { event: "INSERT", schema: "public", table: "messages" },
    (payload) => {
        const incoming = payload.new;

        // se já renderizamos essa mensagem (por id) — provavelmente porque o autor local já renderizou — ignora
        if (incoming.id && renderedMessageIds.has(String(incoming.id))) {
            // opcional: podemos atualizar o username caso estivesse (desconhecido) e agora o profile exista
            // mas para simplicidade, vamos tentar buscar e atualizar apenas se username não está no cache
            if (!usernameCache.has(incoming.user_id)) {
                // tenta buscar e renderizar apenas se ainda não tinha username (não duplica porque check acima)
                fetchUsernameAndRender(incoming);
            }
            return;
        }

        // caso normal: buscar username e renderizar
        fetchUsernameAndRender(incoming);
    }
)
.subscribe();

/* ---------------------- START ---------------------- */
(async () => {
    await checkUser();
    await loadMessages();
})();
</script>

</body>
</html>
