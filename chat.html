<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat em Tempo Real</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        #messages { border: 1px solid #000; height: 400px; overflow-y: auto; padding: 10px; margin-bottom: 20px; background: #f9f9f9; }
        form { display: flex; gap: 10px; }
        input { flex: 1; padding: 10px; }
        .message { margin: 8px 0; padding: 10px; border-radius: 8px; background: white; border-left: 4px solid #007bff; }
        .own-message { background: #e3f2fd; border-left-color: #28a745; }
        .status { padding: 5px; margin: 5px 0; border-radius: 4px; }
        .online { background: #d4edda; color: #155724; }
        .offline { background: #f8d7da; color: #721c24; }
        .verified-badge { color: #1DA1F2; margin-left: 4px; font-weight: bold; }
        .message-time { font-size: 0.8em; color: #666; margin-left: 10px; }
    </style>
</head>
<body>

<h2>üí¨ Chat em Tempo Real</h2>

<div id="connectionStatus" class="status"></div>
<div id="messages"></div>

<form id="sendForm">
    <input id="text" placeholder="Digite sua mensagem..." required>
    <button type="submit">Enviar</button>
</form>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script src="supabase.js"></script>

<script>
let currentUser = null;
let currentUsername = null;
let currentUserVerified = false;
const messagesDiv = document.getElementById("messages");
const statusDiv = document.getElementById("connectionStatus");

function showStatus(message, type = 'online') {
    statusDiv.innerHTML = `<div class="status ${type}">${message}</div>`;
    console.log(`üì¢ ${message}`);
}

/* ---------------------- USER ---------------------- */
async function checkUser() {
    try {
        const { data, error } = await db.auth.getUser();
        if (error || !data.user) {
            showStatus('üîí Usu√°rio n√£o autenticado. Redirecionando...', 'offline');
            setTimeout(() => window.location.href = "login.html", 2000);
            return null;
        }
        currentUser = data.user;
        
        const { data: profile } = await db
            .from('profiles')
            .select('username, verified')
            .eq('id', currentUser.id)
            .single();
            
        currentUsername = profile?.username || currentUser.email;
        currentUserVerified = profile?.verified || false;
        
        showStatus(`üü¢ Conectado como: ${currentUsername} ${currentUserVerified ? '‚úì' : ''}`, 'online');
        return { user: currentUser, username: currentUsername, verified: currentUserVerified };
        
    } catch (error) {
        showStatus('üî¥ Erro ao verificar usu√°rio', 'offline');
        return null;
    }
}

/* ---------------------- RENDER MESSAGE ---------------------- */
function renderMessage(msg) {
    const el = document.createElement("div");
    el.className = "message";
    
    const isOwnMessage = currentUser && msg.user_id === currentUser.id;
    if (isOwnMessage) {
        el.classList.add("own-message");
    }
    
    const username = msg.username || "(desconhecido)";
    const verified = msg.verified || false;
    const content = msg.content;
    
    // Formata a data
    const messageDate = new Date(msg.created_at);
    const timeString = messageDate.toLocaleTimeString('pt-BR', { 
        hour: '2-digit', 
        minute: '2-digit' 
    });

    const verifiedBadge = verified ? '<span class="verified-badge">‚úì</span>' : '';
    const youBadge = isOwnMessage ? ' <small>(voc√™)</small>' : '';

    el.innerHTML = `
        <strong>${username}${verifiedBadge}${youBadge}</strong>
        <span class="message-time">${timeString}</span>
        <div>${content}</div>
    `;
    el.setAttribute('data-message-id', msg.id);

    messagesDiv.appendChild(el);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

/* ---------------------- LOAD MESSAGES ---------------------- */
async function loadMessages() {
    try {
        showStatus('üì• Carregando mensagens...');
        
        const { data, error } = await db
            .from("messages")
            .select(`
                id, 
                content, 
                user_id,
                created_at,
                profiles!inner(username, verified)
            `)
            .order("created_at", { ascending: true });

        if (error) {
            console.error("Erro ao carregar mensagens:", error);
            showStatus('‚ùå Erro ao carregar mensagens', 'offline');
            return;
        }

        messagesDiv.innerHTML = '';
        
        if (data.length === 0) {
            messagesDiv.innerHTML = '<div class="message">üí¨ Nenhuma mensagem ainda. Seja o primeiro a enviar!</div>';
        } else {
            data.forEach(msg => {
                const messageWithData = {
                    ...msg,
                    username: msg.profiles?.username,
                    verified: msg.profiles?.verified
                };
                renderMessage(messageWithData);
            });
            showStatus(`‚úÖ ${data.length} mensagens carregadas`, 'online');
        }

    } catch (err) {
        console.error("Erro ao carregar mensagens:", err);
        showStatus('‚ùå Erro ao carregar mensagens', 'offline');
    }
}

/* ---------------------- SEND MESSAGE ---------------------- */
document.getElementById("sendForm").addEventListener("submit", async (e) => {
    e.preventDefault();

    const textInput = document.getElementById("text");
    const text = textInput.value.trim();

    if (!text) {
        alert("Digite uma mensagem!");
        return;
    }

    try {
        if (!currentUser) {
            await checkUser();
            if (!currentUser) return;
        }

        showStatus('üì§ Enviando mensagem...');

        const { data, error } = await db
            .from("messages")
            .insert({
                user_id: currentUser.id,
                content: text
            })
            .select()
            .single();

        if (error) {
            console.error("Erro ao enviar:", error);
            showStatus('‚ùå Erro ao enviar mensagem', 'offline');
            return;
        }

        // Limpa o input mas N√ÉO renderiza a mensagem aqui
        // Deixa o real-time cuidar disso para todos os usu√°rios
        textInput.value = "";
        showStatus('üü¢ Conectado - Mensagem enviada!', 'online');

    } catch (error) {
        console.error("Erro no envio:", error);
        showStatus('‚ùå Erro inesperado', 'offline');
    }
});

/* ---------------------- REAL-TIME CONNECTION ---------------------- */
function setupRealtime() {
    try {
        showStatus('üîó Conectando ao real-time...');
        
        const channel = db.channel('public:messages')
            .on(
                'postgres_changes',
                {
                    event: 'INSERT',
                    schema: 'public',
                    table: 'messages'
                },
                async (payload) => {
                    console.log('üÜï NOVA MENSAGEM EM TEMPO REAL:', payload);
                    
                    // Verifica se n√£o √© a pr√≥pria mensagem (evita duplicata)
                    if (currentUser && payload.new.user_id === currentUser.id) {
                        console.log('üìù Mensagem pr√≥pria, ignorando duplicata...');
                        return;
                    }
                    
                    showStatus('üÜï Nova mensagem recebida!', 'online');
                    
                    // Busca o username do autor da mensagem
                    const { data: profile } = await db
                        .from('profiles')
                        .select('username, verified')
                        .eq('id', payload.new.user_id)
                        .single();
                    
                    const messageWithUser = {
                        ...payload.new,
                        username: profile?.username || '(desconhecido)',
                        verified: profile?.verified || false
                    };
                    
                    renderMessage(messageWithUser);
                }
            )
            .on('system', { event: 'connected' }, () => {
                console.log('‚úÖ CONECTADO AO REAL-TIME');
                showStatus('üü¢ Conectado em tempo real!', 'online');
            })
            .on('system', { event: 'disconnected' }, () => {
                console.log('‚ùå DESCONECTADO DO REAL-TIME');
                showStatus('üî¥ Desconectado do real-time', 'offline');
            })
            .subscribe((status) => {
                console.log('üì° Status da subscription:', status);
                
                if (status === 'SUBSCRIBED') {
                    showStatus('üü¢ Conectado em tempo real!', 'online');
                } else if (status === 'CHANNEL_ERROR') {
                    showStatus('‚ùå Erro na conex√£o real-time', 'offline');
                } else if (status === 'TIMED_OUT') {
                    showStatus('‚è∞ Timeout na conex√£o', 'offline');
                }
            });

        // Reconectar automaticamente se desconectar
        setInterval(() => {
            if (channel.state !== 'joined') {
                console.log('üîÑ Tentando reconectar...');
                showStatus('üîÑ Reconectando...', 'offline');
                channel.subscribe();
            }
        }, 5000);

        return channel;

    } catch (error) {
        console.error('‚ùå Erro ao configurar real-time:', error);
        showStatus('‚ùå Erro na conex√£o real-time', 'offline');
    }
}

/* ---------------------- INITIALIZE APP ---------------------- */
async function initializeApp() {
    try {
        const userInfo = await checkUser();
        if (userInfo) {
            await loadMessages();
            setupRealtime();
        }
    } catch (error) {
        console.error('‚ùå Erro na inicializa√ß√£o:', error);
        showStatus('‚ùå Erro ao inicializar chat', 'offline');
    }
}

// Inicializa quando a p√°gina carrega
document.addEventListener('DOMContentLoaded', initializeApp);

// Recarregar mensagens quando a p√°gina ganha foco
document.addEventListener('visibilitychange', function() {
    if (!document.hidden) {
        console.log('üîÑ P√°gina vis√≠vel - verificando conex√£o...');
        // Recarrega mensagens se estiver desconectado
        if (statusDiv.textContent.includes('Desconectado')) {
            loadMessages();
        }
    }
});

</script>
</body>
</html>