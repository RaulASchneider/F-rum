<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat</title>

    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
        }

        #messages {
            border: 1px solid #000;
            height: 300px;
            overflow-y: auto;
            padding: 10px;
            margin-bottom: 20px;
        }

        form {
            display: flex;
            gap: 10px;
        }

        input {
            flex: 1;
            padding: 10px;
        }

        .message {
            margin: 5px 0;
            padding: 8px;
            border-radius: 5px;
            background: #f5f5f5;
        }

        .own-message {
            background: #e3f2fd;
            margin-left: 20px;
        }
    </style>
</head>
<body>

<h2>Chat</h2>

<div id="messages"></div>

<form id="sendForm">
    <input id="text" placeholder="Digite..." required>
    <button type="submit">Enviar</button>
</form>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script src="supabase.js"></script>

<script>
// Verifica se o Supabase está inicializado
if (typeof db === 'undefined') {
    console.error('Supabase não foi inicializado. Verifique o arquivo supabase.js');
}

/* ---------------------- USER ---------------------- */
let currentUser = null;

async function checkUser() {
    try {
        const { data, error } = await db.auth.getUser();
        if (error || !data.user) {
            console.error('Usuário não autenticado:', error);
            window.location.href = "login.html";
            return null;
        }
        currentUser = data.user;
        console.log('Usuário autenticado:', currentUser.id);
        return currentUser;
    } catch (error) {
        console.error('Erro ao verificar usuário:', error);
        window.location.href = "login.html";
        return null;
    }
}

/* ---------------------- RENDER ---------------------- */
const messagesDiv = document.getElementById("messages");

function renderMessage(msg) {
    const el = document.createElement("div");
    el.className = "message";
    
    // Destaca mensagens do usuário atual
    if (currentUser && msg.user_id === currentUser.id) {
        el.classList.add("own-message");
    }
    
    const username = msg.username || msg.profiles?.username || "(desconhecido)";
    const content = msg.content;

    el.innerHTML = `<strong>${username}:</strong> ${content}`;
    el.setAttribute('data-message-id', msg.id);
    el.setAttribute('data-user-id', msg.user_id);

    messagesDiv.appendChild(el);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

/* Busca username de 1 usuário - VERSÃO CORRIGIDA */
async function fetchUsernameAndRender(msg) {
    try {
        console.log('Buscando username para user_id:', msg.user_id);
        
        // Tenta buscar da tabela profiles
        const { data, error } = await db
            .from("profiles")
            .select("username")
            .eq("id", msg.user_id)
            .single();

        if (error) {
            console.error("Erro ao buscar username:", error);
            
            // Se não encontrar em profiles, tenta buscar do user_metadata
            if (currentUser && msg.user_id === currentUser.id) {
                msg.username = currentUser.user_metadata?.username || "Você";
            } else {
                // Para outros usuários, tenta uma abordagem alternativa
                await tryAlternativeUsernameFetch(msg);
                return;
            }
        } else {
            console.log('Username encontrado:', data.username);
            msg.username = data.username;
        }
        
        renderMessage(msg);
    } catch (err) {
        console.error("Erro na busca de username:", err);
        msg.username = "(desconhecido)";
        renderMessage(msg);
    }
}

/* Tentativa alternativa de buscar username */
async function tryAlternativeUsernameFetch(msg) {
    try {
        // Tenta buscar através da tabela auth.users (se as permissões permitirem)
        const { data, error } = await db
            .from("auth.users")
            .select("raw_user_meta_data")
            .eq("id", msg.user_id)
            .single();

        if (!error && data && data.raw_user_meta_data) {
            msg.username = data.raw_user_meta_data.username || data.raw_user_meta_data.full_name || "(usuário)";
        } else {
            msg.username = `Usuário ${msg.user_id.substring(0, 8)}`;
        }
    } catch (err) {
        msg.username = `Usuário ${msg.user_id.substring(0, 8)}`;
    }
    
    renderMessage(msg);
}

/* ---------------------- LOAD MESSAGES ---------------------- */
async function loadMessages() {
    try {
        console.log('Carregando mensagens...');
        
        // LIMPA as mensagens antes de carregar
        messagesDiv.innerHTML = '<div>Carregando mensagens...</div>';
        
        // Busca mensagens com ordenação EXPLÍCITA por data de criação
        const { data, error } = await db
            .from("messages")
            .select(`
                id, 
                content, 
                user_id,
                created_at,
                profiles (username)
            `)
            .order("created_at", { ascending: true }); // ASCENDENTE para ordem correta

        if (error) {
            console.error("Erro ao carregar mensagens:", error);
            messagesDiv.innerHTML = '<div>Erro ao carregar mensagens</div>';
            return;
        }

        console.log(`Carregadas ${data.length} mensagens em ordem:`, data.map(m => ({id: m.id, created_at: m.created_at})));

        // LIMPA novamente antes de renderizar
        messagesDiv.innerHTML = '';

        if (data.length === 0) {
            messagesDiv.innerHTML = '<div>Nenhuma mensagem ainda. Seja o primeiro a enviar!</div>';
            return;
        }

        // Processa cada mensagem garantindo ordem correta
        for (const msg of data) {
            if (msg.profiles && msg.profiles.username) {
                // Se o join trouxe o username, renderiza diretamente
                renderMessage(msg);
            } else {
                // Se não trouxe, busca individualmente
                await fetchUsernameAndRender(msg);
            }
        }

        console.log('Todas as mensagens foram renderizadas');

    } catch (err) {
        console.error("Erro geral ao carregar mensagens:", err);
        messagesDiv.innerHTML = '<div>Erro ao carregar mensagens</div>';
    }
}

/* ---------------------- SEND ---------------------- */
document.getElementById("sendForm").addEventListener("submit", async (e) => {
    e.preventDefault();

    const textInput = document.getElementById("text");
    const text = textInput.value.trim();

    if (!text) {
        alert("Digite uma mensagem!");
        return;
    }

    try {
        if (!currentUser) {
            await checkUser();
        }

        if (!currentUser) {
            alert("Usuário não autenticado!");
            return;
        }

        console.log('Enviando mensagem:', text);

        const { data, error } = await db
            .from("messages")
            .insert({
                user_id: currentUser.id,
                content: text
            })
            .select()
            .single();

        if (error) {
            console.error("Erro ao enviar mensagem:", error);
            alert("Erro ao enviar mensagem: " + error.message);
            return;
        }

        console.log('Mensagem enviada com sucesso:', data);

        // Adiciona o username à mensagem
        const newMessage = {
            ...data,
            username: currentUser.user_metadata?.username || currentUser.email || "Você"
        };
        
        renderMessage(newMessage);
        textInput.value = "";
        textInput.focus();

    } catch (error) {
        console.error("Erro no envio:", error);
        alert("Erro inesperado: " + error.message);
    }
});

/* ---------------------- REALTIME ---------------------- */
function setupRealtime() {
    try {
        const channel = db.channel("public:messages")
            .on(
                "postgres_changes",
                { 
                    event: "INSERT", 
                    schema: "public", 
                    table: "messages" 
                },
                async (payload) => {
                    console.log("Nova mensagem em tempo real:", payload);
                    
                    // Verifica se a mensagem já não foi renderizada (evita duplicatas)
                    const existingMessage = document.querySelector(`[data-message-id="${payload.new.id}"]`);
                    if (!existingMessage) {
                        await fetchUsernameAndRender(payload.new);
                    }
                }
            )
            .subscribe((status) => {
                console.log("Status da subscription realtime:", status);
            });

        return channel;

    } catch (error) {
        console.error("Erro ao configurar realtime:", error);
    }
}

/* ---------------------- START ---------------------- */
async function initializeApp() {
    try {
        const user = await checkUser();
        if (user) {
            console.log('App inicializado para usuário:', user.id);
            await loadMessages();
            setupRealtime();
        }
    } catch (error) {
        console.error('Erro na inicialização do app:', error);
    }
}

// Inicializa o app quando a página carregar
document.addEventListener('DOMContentLoaded', initializeApp);

// Também recarrega as mensagens quando a página ganha foco (útil para testar ordenação)
document.addEventListener('visibilitychange', function() {
    if (!document.hidden) {
        console.log('Página visível - verificando mensagens...');
        // Pode recarregar mensagens se necessário
        // loadMessages();
    }
});

</script>

</body>
</html>